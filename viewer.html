<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>CLRS probe visualizer (v5.4)</title>
    <style>
        :root{
          --bg:#ffffff;
          --panel:#fafafa;
          --border:#ddd;
          --muted:#666;
          --text:#111;
          --shadow: 0 1px 10px rgba(0,0,0,0.06);
          --radius: 10px;
          --gap: 14px;
        }
        body{
          font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
          margin: 0;
          background: var(--bg);
          color: var(--text);
        }
        header{
          position: sticky;
          top: 0;
          z-index: 5;
          background: rgba(255,255,255,0.9);
          backdrop-filter: blur(8px);
          border-bottom: 1px solid var(--border);
          padding: 12px 16px;
          display:flex;
          align-items:center;
          justify-content: space-between;
          gap: 12px;
        }
        header h2{
          margin:0;
          font-size: 16px;
          letter-spacing: 0.2px;
        }

        .wrap{
          display:grid;
          grid-template-columns: 380px 1fr;
          gap: 16px;
          padding: 16px;
          align-items: start;
        }
        @media (max-width: 980px){
          .wrap{ grid-template-columns: 1fr; }
          header{ position: static; }
        }

        .controls{
          display:grid;
          gap: 12px;
          min-width: 320px;
          background: var(--panel);
          border: 1px solid var(--border);
          border-radius: var(--radius);
          padding: 12px;
          box-shadow: var(--shadow);
          position: sticky;
          top: 58px;
          max-height: calc(100vh - 84px);
          overflow: auto;
        }
        @media (max-width: 980px){
          .controls{ position: static; max-height: none; }
        }

        label{ font-size: 13px; display: grid; gap: 6px; }
        .inline{ display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        input[type="range"]{ width: 100%; }
        button{ padding: 6px 10px; border: 1px solid var(--border); border-radius: 8px; background: #fff; cursor:pointer; }
        button:hover{ background:#f3f3f3; }
        select, input[type="number"]{
          padding: 5px 7px; border-radius: 8px; border: 1px solid var(--border); background:#fff;
        }
        input[type="file"]{ padding: 6px; border-radius: 10px; border: 1px dashed var(--border); background:#fff; }

        .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .small{ font-size: 12px; color: var(--muted); line-height: 1.35; }
        .legend{ display:flex; align-items:center; gap: 8px; }
        .swatch{ width: 140px; height: 14px; background: linear-gradient(to right, white, black); border:1px solid var(--border); border-radius: 6px; }

        .probeListBox{
          background: #fff;
          border: 1px solid var(--border);
          border-radius: 10px;
          padding: 8px;
          max-height: 260px;
          overflow:auto;
        }
        .probeRow{
          display:flex;
          align-items:center;
          gap: 8px;
          padding: 4px 4px;
          border-radius: 8px;
          user-select: none;
        }
        .probeRow:hover{ background:#f4f4f4; }
        .badge{
          font-size: 11px;
          padding: 2px 6px;
          border-radius: 999px;
          border: 1px solid var(--border);
          background: #fff;
          color: #333;
          margin-left: auto;
          white-space: nowrap;
        }

        .hoverPanel{
          border: 1px solid var(--border);
          border-radius: var(--radius);
          background: #fff;
          padding: 10px 10px;
          box-shadow: var(--shadow);
          min-height: 64px; /* reserve space to avoid layout shifts */
          display: grid;
          gap: 6px;
        }
        .hoverTitle{
          font-size: 11px;
          color: var(--muted);
          text-transform: uppercase;
          letter-spacing: 0.06em;
        }
        .hoverText{
          font-size: 12px;
          color: #111;
          line-height: 1.35;
          white-space: pre-wrap;
          word-break: break-word;
          min-height: 24px;
        }

        .main{
          display:grid;
          gap: 12px;
          min-width: 0;
        }
        .toolbar{
          display:flex;
          flex-wrap: wrap;
          gap: 10px;
          align-items: center;
          justify-content: space-between;
          background: var(--panel);
          border: 1px solid var(--border);
          border-radius: var(--radius);
          padding: 10px 12px;
          box-shadow: var(--shadow);
        }
        .toolbar .left, .toolbar .right{
          display:flex;
          flex-wrap: wrap;
          gap: 10px;
          align-items: center;
        }

        /* Cards stacked vertically */
        .cards{
          display: flex;
          flex-direction: column;
          gap: var(--gap);
          align-items: stretch;
          min-width: 0;
        }

        .card{
          background: #fff;
          border: 1px solid var(--border);
          border-radius: var(--radius);
          box-shadow: var(--shadow);
          padding: 10px;
          display:grid;
          gap: 10px;
          min-width: 0;
        }

        .cardHeader{
          display:flex;
          align-items: baseline;
          gap: 10px;
          justify-content: space-between;
          min-width: 0;
        }
        .title{
          font-weight: 650;
          font-size: 13px;
          color: #222;
          display:flex;
          align-items: baseline;
          gap: 8px;
          flex-wrap: wrap;
          min-width: 0;
        }
        .subtitle{
          font-size: 12px;
          color: var(--muted);
          white-space: nowrap;
        }

        .block{
          display:grid;
          gap: 6px;
          min-width: 0;
        }
        .blockTitle{
          font-size: 11px;
          color: var(--muted);
          display:flex;
          justify-content: space-between;
          align-items: center;
          gap: 8px;
          min-width: 0;
        }
        .shapeNote{
          font-size: 11px;
          color: #888;
          white-space: nowrap;
          overflow:hidden;
          text-overflow: ellipsis;
          max-width: 260px;
        }

        .canvasWrap{
          border: 1px solid #eee;
          border-radius: 10px;
          padding: 8px;
          background: #fcfcfc;
          overflow: auto;
          max-width: 100%;
          max-height: 560px;
          min-width: 0;
        }
        canvas{
          border: 1px solid #ccc;
          image-rendering: pixelated;
          border-radius: 6px;
          background: #fff;
          display:block;
        }

        /* Vector: stacked vertically */
        .vectorStack{
          display:grid;
          grid-template-columns: 1fr;
          gap: 10px;
        }

        /* Matrix: true | pred | err side-by-side */
        .matrixRow{
          display:flex;
          flex-wrap: wrap;
          gap: 12px;
          align-items: flex-start;
        }
        .matrixRow .block{
          flex: 0 0 auto;
          width: fit-content;
          max-width: 100%;
        }
        .matrixRow .canvasWrap{
          width: fit-content;
          max-width: 100%;
        }
    </style>
</head>
<body>
<header>
    <h2>CLRS probe visualizer</h2>
    <div class="small mono" id="topMeta"></div>
</header>

<div class="wrap">
    <div class="controls">
        <label>
            Load JSON:
            <input id="file" type="file" accept=".json" />
        </label>

        <div class="inline">
            <label style="flex:1; min-width: 160px;">
                Batch index:
                <input id="bidx" type="number" value="0" min="0" />
            </label>
            <label style="flex:1; min-width: 160px;">
                FPS:
                <input id="fps" type="number" value="6" min="1" max="60" />
            </label>
        </div>

        <label>
            Time:
            <input id="t" type="range" min="0" max="0" value="0" step="1" />
            <span id="tLabel" class="mono"></span>
        </label>

        <div class="inline">
            <button id="play">Play</button>
            <button id="pause">Pause</button>
            <button id="all">All</button>
            <button id="none">None</button>
        </div>

        <div class="inline">
            <label style="flex:1; min-width: 160px;">
                Vector cell size:
                <input id="vcell" type="number" value="13" min="1" max="120" />
            </label>
            <label style="flex:1; min-width: 160px;">
                Matrix cell size:
                <input id="mcell" type="number" value="4" min="1" max="80" />
            </label>
        </div>

        <!-- Global matrix subrange selector -->
        <div class="inline">
            <label style="flex:1; min-width: 160px;">
                Rows [start,end):
                <div class="inline" style="gap:6px;">
                    <input id="r0" type="number" value="0" min="0" style="width:80px;" />
                    <input id="r1" type="number" value="0" min="0" style="width:80px;" />
                </div>
            </label>
            <label style="flex:1; min-width: 160px;">
                Cols [start,end):
                <div class="inline" style="gap:6px;">
                    <input id="c0" type="number" value="0" min="0" style="width:80px;" />
                    <input id="c1" type="number" value="0" min="0" style="width:80px;" />
                </div>
            </label>
        </div>

        <label>
            Contrast:
            <input id="contrast" type="range" min="0.2" max="6" value="1" step="0.1" />
            <span id="contrastLabel" class="mono"></span>
        </label>

        <label class="inline">
            <input id="lockScale" type="checkbox" checked />
            <span>Lock color scale across time</span>
        </label>

        <div class="legend small">
            <div class="swatch"></div>
            <div><span class="mono">white=0</span> → <span class="mono">black=1</span></div>
        </div>

        <label>
            Probes to view:
            <div id="probeList" class="probeListBox small"></div>
        </label>

        <hr />
        <div>
          <div class="inline" style="align-items:center;">
            <label class="inline" style="margin: 6px 0;">
              <input id="showPca" type="checkbox" />
              <span>PCA: show trajectory of GNN hidden states</span>
            </label>
          </div>
          <div class="inline">
            <label style="flex:1; min-width: 130px;">
              PC for X-axis (1-based):
              <input id="pcx" type="number" value="1" min="1" style="width:88px;" />
            </label>
            <label style="flex:1; min-width: 130px;">
              PC for Y-axis (1-based):
              <input id="pcy" type="number" value="2" min="1" style="width:88px;" />
            </label>
          </div>
          <div class="small" id="pcaInfo" style="color:var(--muted);"></div>
        </div>

        <!-- Node-wise PCA panel -->
        <div>
          <div class="inline" style="align-items:center;">
            <label class="inline" style="margin: 6px 0;">
              <input id="showPcaNodes" type="checkbox" />
              <span>PCA: nodes at current time (basis from all times)</span>
            </label>
          </div>
          <div class="inline">
            <label style="flex:1; min-width: 130px;">
              PC for X-axis (1-based):
              <input id="pcxNodes" type="number" value="1" min="1" style="width:88px;" />
            </label>
            <label style="flex:1; min-width: 130px;">
              PC for Y-axis (1-based):
              <input id="pcyNodes" type="number" value="2" min="1" style="width:88px;" />
            </label>
          </div>
          <div class="small" id="pcaNodesInfo" style="color:var(--muted);"></div>
        </div>

        <div class="hoverPanel">
            <div class="hoverTitle">Hover value</div>
            <div id="hoverText" class="hoverText mono">Hover any cell to see its value here.</div>
        </div>

        <div id="meta" class="small mono"></div>
    </div>

    <div class="main">
        <div class="toolbar">
            <div class="left small mono" id="algoName"></div>
            <div class="right small mono" id="summary"></div>
        </div>

        <div id="cardsContainer" class="cards"></div>
        <div id="pcaContainer" style="margin-top:16px; display:none;">
          <div class="small mono" id="pcaTitle" style="margin:6px 2px;">PCA trajectory</div>
          <canvas id="pcaCanvas" style="width:100%; height:320px; border:1px solid var(--border); border-radius:8px; background:#fff;"></canvas>
        </div>
        <div id="pcaNodesContainer" style="margin-top:16px; display:none;">
          <div class="small mono" id="pcaNodesTitle" style="margin:6px 2px;">PCA (nodes at current time)</div>
          <canvas id="pcaNodesCanvas" style="width:100%; height:320px; border:1px solid var(--border); border-radius:8px; background:#fff;"></canvas>
        </div>
    </div>
</div>

<script src="pca.js"></script>
<script>
    (() => {
      const elFile = document.getElementById('file');
      const elBidx = document.getElementById('bidx');
      const elFps  = document.getElementById('fps');
      const elT    = document.getElementById('t');
      const elTLabel = document.getElementById('tLabel');
      const elVCell = document.getElementById('vcell');
      const elMCell = document.getElementById('mcell');
      const elR0 = document.getElementById('r0');
      const elR1 = document.getElementById('r1');
      const elC0 = document.getElementById('c0');
      const elC1 = document.getElementById('c1');
      const elContrast = document.getElementById('contrast');
      const elContrastLabel = document.getElementById('contrastLabel');
      const elLockScale = document.getElementById('lockScale');
      const elMeta = document.getElementById('meta');
      const elTopMeta = document.getElementById('topMeta');
      const elAlgoName = document.getElementById('algoName');
      const elSummary = document.getElementById('summary');
      const elHoverText = document.getElementById('hoverText');

      // PCA controls
      const elShowPca = document.getElementById('showPca');
      const elPcx = document.getElementById('pcx');
      const elPcy = document.getElementById('pcy');
      const elPcaInfo = document.getElementById('pcaInfo');
      const elPcaContainer = document.getElementById('pcaContainer');
      const elPcaCanvas = document.getElementById('pcaCanvas');
      const elPcaTitle = document.getElementById('pcaTitle');
      // Node-wise PCA controls
      const elShowPcaNodes = document.getElementById('showPcaNodes');
      const elPcxNodes = document.getElementById('pcxNodes');
      const elPcyNodes = document.getElementById('pcyNodes');
      const elPcaNodesInfo = document.getElementById('pcaNodesInfo');
      const elPcaNodesContainer = document.getElementById('pcaNodesContainer');
      const elPcaNodesCanvas = document.getElementById('pcaNodesCanvas');
      const elPcaNodesTitle = document.getElementById('pcaNodesTitle');

      const btnPlay = document.getElementById('play');
      const btnPause = document.getElementById('pause');
      const btnAll = document.getElementById('all');
      const btnNone = document.getElementById('none');

      const elProbeList = document.getElementById('probeList');
      const elCardsContainer = document.getElementById('cardsContainer');

      let algo = null;      // ONLY multi-probe format supported
      let timer = null;

      const selectedState = new Map();
      const scaleCache = new Map();
      // Cache for node-wise PCA basis so we don't recompute when scrubbing time
      const nodePcaCache = { key: null, pca: null };

      // Fixed categorical palette (muted, readable)
      const CAT_PALETTE = [
        '#4E79A7', // blue
        '#F28E2B', // orange
        '#59A14F', // green
        '#E15759', // red
        '#B07AA1', // purple
        '#9C755F', // brown
        '#76B7B2', // teal
        '#EDC948', // yellow
        '#FF9DA7', // pink
        '#BAB0AC', // gray
      ];

      function stop(){ if (timer) clearInterval(timer); timer=null; }
      function play(){
        stop();
        const fps = Math.max(1, Math.min(60, Number(elFps.value) || 6));
        timer = setInterval(() => {
          const maxT = Number(elT.max);
          let t = Number(elT.value);
          t = (t >= maxT) ? 0 : (t + 1);
          elT.value = String(t);
          detectAndRender();
        }, Math.round(1000 / fps));
      }

      function clamp01(x) { return Math.max(0, Math.min(1, x)); }
      function probToGray(p, contrast=1.0) {
        p = clamp01((p - 0.5) * contrast + 0.5);
        const g = Math.round(255 * (1 - p));
        return `rgb(${g},${g},${g})`;
      }

      function getDims(arr) {
        const dims = [];
        let cur = arr;
        while (Array.isArray(cur)) {
          dims.push(cur.length);
          cur = cur[0];
        }
        return dims;
      }

      function setHoverText(s){
        elHoverText.textContent = s || "Hover any cell to see its value here.";
      }

      function isCategoricalType(typeStr) {
        if (!typeStr) return false;
        const s = String(typeStr).toLowerCase();
        // Treat MASK_ONE like categorical for rendering ([B,T,N,K] with K classes)
        return s.includes('categorical') || s.includes('mask_one');
      }


      function labelToColor(label) {
        const idx = ((label|0) % CAT_PALETTE.length + CAT_PALETTE.length) % CAT_PALETTE.length;
        return CAT_PALETTE[idx];
      }

      function argmax1D(arrK) {
        let best = 0;
        let bestV = Number(arrK[0]);
        for (let k=1;k<arrK.length;k++){
          const v = Number(arrK[k]);
          if (v > bestV) { bestV = v; best = k; }
        }
        return best;
      }

      function validTFromIsLast(bIdx) {
        const isLast = algo?.is_last;
        if (!Array.isArray(isLast) || isLast.length === 0) return null;
        const b = Math.max(0, Math.min(isLast.length - 1, bIdx));
        const row = isLast[b];
        if (!Array.isArray(row) || row.length === 0) return null;
        for (let t=0; t<row.length; t++){
          if (row[t] === true) return t + 1; // inclusive
        }
        return row.length;
      }

      function validTFromLengths(bIdx, selectedNames) {
        const probesMap = algo?.probes || {};
        const globalLengths = Array.isArray(algo?.lengths) ? algo.lengths : null;
        let best = Infinity;
        const b = Math.max(0, bIdx|0);
        for (const name of selectedNames){
          const p = probesMap[name];
          if (!p || p.error) continue;
          const lengths = Array.isArray(p.lengths) ? p.lengths : globalLengths;
          if (Array.isArray(lengths) && lengths.length > b){
            const L = Number(lengths[b]);
            if (Number.isFinite(L) && L > 0) best = Math.min(best, L);
          }
        }
        return (best !== Infinity) ? best : null;
      }

      function makeTimeVectorViewWithLengths(tensor, lengths) {
        const dims = getDims(tensor);
        const L = Array.isArray(lengths) ? lengths.length : null;

        if (dims.length === 2) {
          const [T,N]=dims;
          return { kind:'vector', dims, T, N, B:1, b:0, get:(t,j)=>tensor[t][j] };
        }
        if (dims.length === 3) {
          const [d0,d1,d2]=dims;
          // Do NOT early-classify as matrix just because T==N; rely on metadata/heuristics below.

          if (L!=null) {
            if (d0===L) {
              const B=d0,T=d1,N=d2;
              const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
              return { kind:'vector', dims, T, N, B, b, get:(t,j)=>tensor[b][t][j] };
            }
            if (d1===L) {
              const T=d0,B=d1,N=d2;
              const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
              return { kind:'vector', dims, T, N, B, b, get:(t,j)=>tensor[t][b][j] };
            }
          }
          const useBTN = (d0 <= 64 && d1 > d0);
          if (useBTN) {
            const B=d0,T=d1,N=d2;
            const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
            return { kind:'vector', dims, T, N, B, b, get:(t,j)=>tensor[b][t][j] };
          }
          const T=d0,B=d1,N=d2;
          const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
          return { kind:'vector', dims, T, N, B, b, get:(t,j)=>tensor[t][b][j] };
        }
        throw new Error('not-vector');
      }

      function makeTimeMatrixViewWithLengths(tensor, lengths) {
        const dims = getDims(tensor);
        const L = Array.isArray(lengths) ? lengths.length : null;

        if (dims.length === 2) {
          const [H,W]=dims; const T=1;
          return { kind:'matrix', dims:[T,H,W], T, H, W, B:1, b:0, get:(_t,i,j)=>tensor[i][j] };
        }
        if (dims.length === 3) {
          const [T,H,W]=dims;
          return { kind:'matrix', dims, T, H, W, B:1, b:0, get:(t,i,j)=>tensor[t][i][j] };
        }
        if (dims.length === 4) {
          const [d0,d1,H,W]=dims;
          if (L!=null) {
            if (d0===L) {
              const B=d0,T=d1;
              const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
              return { kind:'matrix', dims, T, H, W, B, b, get:(t,i,j)=>tensor[b][t][i][j] };
            }
            if (d1===L) {
              const T=d0,B=d1;
              const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
              return { kind:'matrix', dims, T, H, W, B, b, get:(t,i,j)=>tensor[t][b][i][j] };
            }
          }
          if (d0 <= 64 && d1 > d0) {
            const B=d0,T=d1;
            const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
            return { kind:'matrix', dims, T, H, W, B, b, get:(t,i,j)=>tensor[b][t][i][j] };
          }
          const T=d0,B=d1;
          const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
          return { kind:'matrix', dims, T, H, W, B, b, get:(t,i,j)=>tensor[t][b][i][j] };
        }
        throw new Error('not-matrix');
      }

      // --- CATEGORICAL views ---
      // [B,T,N,K] or [T,B,N,K]  (we handle batch axis via lengths if possible)
      function makeTimeCategoricalVectorView(tensor, lengths) {
        const dims = getDims(tensor);
        const L = Array.isArray(lengths) ? lengths.length : null;

        if (dims.length !== 4) throw new Error('not-cat-vector');
        const [d0,d1,d2,d3] = dims;
        const K = d3;

        if (L != null) {
          if (d0 === L) { // [B,T,N,K]
            const B=d0,T=d1,N=d2;
            const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
            return { kind:'catvec', dims, B, T, N, K, b, get:(t,j,k)=>tensor[b][t][j][k] };
          }
          if (d1 === L) { // [T,B,N,K]
            const T=d0,B=d1,N=d2;
            const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
            return { kind:'catvec', dims, B, T, N, K, b, get:(t,j,k)=>tensor[t][b][j][k] };
          }
        }
        // heuristic: assume [B,T,N,K]
        const B=d0,T=d1,N=d2;
        const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
        return { kind:'catvec', dims, B, T, N, K, b, get:(t,j,k)=>tensor[b][t][j][k] };
      }

      // [B,T,H,W,K] or [T,B,H,W,K]
      function makeTimeCategoricalMatrixView(tensor, lengths) {
        const dims = getDims(tensor);
        const L = Array.isArray(lengths) ? lengths.length : null;

        if (dims.length !== 5) throw new Error('not-cat-matrix');
        const [d0,d1,H,W,K] = dims;

        if (L != null) {
          if (d0 === L) { // [B,T,H,W,K]
            const B=d0,T=d1;
            const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
            return { kind:'catmat', dims, B, T, H, W, K, b, get:(t,i,j,k)=>tensor[b][t][i][j][k] };
          }
          if (d1 === L) { // [T,B,H,W,K]
            const T=d0,B=d1;
            const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
            return { kind:'catmat', dims, B, T, H, W, K, b, get:(t,i,j,k)=>tensor[t][b][i][j][k] };
          }
        }
        // heuristic: assume [B,T,H,W,K]
        const B=d0,T=d1;
        const b=Math.max(0,Math.min(B-1,Number(elBidx.value)||0)); elBidx.max=B-1;
        return { kind:'catmat', dims, B, T, H, W, K, b, get:(t,i,j,k)=>tensor[b][t][i][j][k] };
      }

      function finalizeScale(values){
        if (!values || values.length===0) return { bothIn01:true,min:0,max:1 };
        let minV=Infinity,maxV=-Infinity,allIn01=true;
        for (const v of values){
          if(!Number.isFinite(v)) continue;
          if(v<minV) minV=v;
          if(v>maxV) maxV=v;
          if(!(v>=0 && v<=1)) allIn01=false;
        }
        if (minV===Infinity) return {bothIn01:true,min:0,max:1};
        if (allIn01) return {bothIn01:true,min:0,max:1};
        if (maxV===minV) maxV=minV+1e-6;
        return {bothIn01:false,min:minV,max:maxV};
      }

      function computeProbeScale(probe, lengths) {
        if (!probe || !probe.true || !probe.pred) return {bothIn01:true,min:0,max:1};

        // Categorical: scale doesn't make sense for label map; return [0,1]
        if (isCategoricalType(probe.type)) {
          return {bothIn01:true, min:0, max:1};
        }

        try {
          const vTrue = makeTimeVectorViewWithLengths(probe.true, lengths);
          const vPred = makeTimeVectorViewWithLengths(probe.pred, lengths);
          const N = Math.min(vTrue.N, vPred.N);
          const T = Math.min(vTrue.T, vPred.T);
          let values = [];
          for (let t=0;t<T;t++){
            for (let j=0;j<N;j++){
              const a = Number(vTrue.get(t,j));
              const b = Number(vPred.get(t,j));
              if (Number.isFinite(a)) values.push(a);
              if (Number.isFinite(b)) values.push(b);
            }
          }
          return finalizeScale(values);
        } catch(_) {}

        try {
          const mTrue = makeTimeMatrixViewWithLengths(probe.true, lengths);
          const mPred = makeTimeMatrixViewWithLengths(probe.pred, lengths);
          const H = Math.min(mTrue.H, mPred.H);
          const W = Math.min(mTrue.W, mPred.W);
          const T = Math.min(mTrue.T, mPred.T);

          let r0 = Math.max(0, parseInt(elR0.value||'0',10));
          let r1 = Math.max(0, parseInt(elR1.value||'0',10));
          let c0 = Math.max(0, parseInt(elC0.value||'0',10));
          let c1 = Math.max(0, parseInt(elC1.value||'0',10));
          if (!Number.isFinite(r0)) r0 = 0; if (!Number.isFinite(c0)) c0 = 0;
          if (!Number.isFinite(r1) || r1===0) r1 = H; if (!Number.isFinite(c1) || c1===0) c1 = W;
          r0 = Math.min(r0, H); r1 = Math.min(Math.max(r1, r0+0), H);
          c0 = Math.min(c0, W); c1 = Math.min(Math.max(c1, c0+0), W);

          let values = [];
          for (let t=0;t<T;t++){
            for (let i=r0;i<r1;i++){
              for (let j=c0;j<c1;j++){
                const a = Number(mTrue.get(t,i,j));
                const b = Number(mPred.get(t,i,j));
                if (Number.isFinite(a)) values.push(a);
                if (Number.isFinite(b)) values.push(b);
              }
            }
          }
          return finalizeScale(values);
        } catch(_) {}

        return {bothIn01:true,min:0,max:1};
      }

      function computeProbeErrScale(probe, lengths) {
        if (!probe || !probe.true || !probe.pred) return {bothIn01:true,min:0,max:1};

        // Categorical error: mismatch is binary
        if (isCategoricalType(probe.type)) {
          return {bothIn01:true, min:0, max:1};
        }

        try {
          const vTrue = makeTimeVectorViewWithLengths(probe.true, lengths);
          const vPred = makeTimeVectorViewWithLengths(probe.pred, lengths);
          const N = Math.min(vTrue.N, vPred.N);
          const T = Math.min(vTrue.T, vPred.T);
          let maxV = 0;
          for (let t=0;t<T;t++){
            for (let j=0;j<N;j++){
              const a = Number(vTrue.get(t,j));
              const b = Number(vPred.get(t,j));
              const e = Math.abs(b - a);
              if (Number.isFinite(e) && e > maxV) maxV = e;
            }
          }
          if (maxV <= 1) return {bothIn01:true,min:0,max:1};
          return {bothIn01:false,min:0,max:Math.max(maxV,1e-6)};
        } catch(_) {}

        try {
          const mTrue = makeTimeMatrixViewWithLengths(probe.true, lengths);
          const mPred = makeTimeMatrixViewWithLengths(probe.pred, lengths);
          const H = Math.min(mTrue.H, mPred.H);
          const W = Math.min(mTrue.W, mPred.W);
          const T = Math.min(mTrue.T, mPred.T);

          let r0 = Math.max(0, parseInt(elR0.value||'0',10));
          let r1 = Math.max(0, parseInt(elR1.value||'0',10));
          let c0 = Math.max(0, parseInt(elC0.value||'0',10));
          let c1 = Math.max(0, parseInt(elC1.value||'0',10));
          if (!Number.isFinite(r0)) r0 = 0; if (!Number.isFinite(c0)) c0 = 0;
          if (!Number.isFinite(r1) || r1===0) r1 = H; if (!Number.isFinite(c1) || c1===0) c1 = W;
          r0 = Math.min(r0, H); r1 = Math.min(Math.max(r1, r0+0), H);
          c0 = Math.min(c0, W); c1 = Math.min(Math.max(c1, c0+0), W);

          let maxV = 0;
          for (let t=0;t<T;t++){
            for (let i=r0;i<r1;i++){
              for (let j=c0;j<c1;j++){
                const a = Number(mTrue.get(t,i,j));
                const b = Number(mPred.get(t,i,j));
                const e = Math.abs(b - a);
                if (Number.isFinite(e) && e > maxV) maxV = e;
              }
            }
          }
          if (maxV <= 1) return {bothIn01:true,min:0,max:1};
          return {bothIn01:false,min:0,max:Math.max(maxV,1e-6)};
        } catch(_) {}

        return {bothIn01:true,min:0,max:1};
      }

      function drawVectorTo(ctx, canvas, raw, scale, cell, contrast) {
        const N = raw.length;
        canvas.width = Math.max(1, N * cell);
        canvas.height = Math.max(1, cell);
        ctx.clearRect(0,0,canvas.width,canvas.height);

        const bothIn01 = scale.bothIn01;
        const gmin = scale.min;
        const gden = (scale.max - scale.min) || 1;

        for (let j=0;j<N;j++){
          const val=raw[j];
          const p = (bothIn01 ? val : ((val - gmin) / gden));
          ctx.fillStyle = probToGray(p, contrast);
          ctx.fillRect(j*cell, 0, cell, cell);
        }
        ctx.strokeStyle='rgba(0,0,0,0.10)';
        for (let j=0;j<=N;j++){
          ctx.beginPath(); ctx.moveTo(j*cell+0.5,0); ctx.lineTo(j*cell+0.5,cell); ctx.stroke();
        }
        ctx.beginPath(); ctx.moveTo(0,cell+0.5); ctx.lineTo(N*cell,cell+0.5); ctx.stroke();
      }

      function drawMatrixTo(ctx, canvas, H, W, getVal, scale, cell, contrast) {
        canvas.width = Math.max(1, W * cell);
        canvas.height = Math.max(1, H * cell);
        ctx.clearRect(0,0,canvas.width,canvas.height);

        const bothIn01 = scale.bothIn01;
        const gmin = scale.min;
        const gden = (scale.max - scale.min) || 1;

        for (let i=0;i<H;i++){
          for (let j=0;j<W;j++){
            const v = Number(getVal(i,j));
            const p = (bothIn01 ? v : ((v - gmin) / gden));
            ctx.fillStyle = probToGray(p, contrast);
            ctx.fillRect(j*cell, i*cell, cell, cell);
          }
        }
        ctx.strokeStyle='rgba(0,0,0,0.08)';
        for (let i=0;i<=H;i++){
          ctx.beginPath(); ctx.moveTo(0,i*cell+0.5); ctx.lineTo(W*cell,i*cell+0.5); ctx.stroke();
        }
        for (let j=0;j<=W;j++){
          ctx.beginPath(); ctx.moveTo(j*cell+0.5,0); ctx.lineTo(j*cell+0.5,H*cell); ctx.stroke();
        }
      }

      function drawCategoricalVector(ctx, canvas, labels, cell) {
        const N = labels.length;
        canvas.width = Math.max(1, N * cell);
        canvas.height = Math.max(1, cell);
        ctx.clearRect(0,0,canvas.width,canvas.height);

        for (let j=0;j<N;j++){
          ctx.fillStyle = labelToColor(labels[j]);
          ctx.fillRect(j*cell, 0, cell, cell);
        }
        ctx.strokeStyle='rgba(0,0,0,0.12)';
        for (let j=0;j<=N;j++){
          ctx.beginPath(); ctx.moveTo(j*cell+0.5,0); ctx.lineTo(j*cell+0.5,cell); ctx.stroke();
        }
        ctx.beginPath(); ctx.moveTo(0,cell+0.5); ctx.lineTo(N*cell,cell+0.5); ctx.stroke();
      }

      function drawCategoricalMatrix(ctx, canvas, H, W, getLabel, cell) {
        canvas.width = Math.max(1, W * cell);
        canvas.height = Math.max(1, H * cell);
        ctx.clearRect(0,0,canvas.width,canvas.height);

        for (let i=0;i<H;i++){
          for (let j=0;j<W;j++){
            ctx.fillStyle = labelToColor(getLabel(i,j));
            ctx.fillRect(j*cell, i*cell, cell, cell);
          }
        }
        ctx.strokeStyle='rgba(0,0,0,0.10)';
        for (let i=0;i<=H;i++){
          ctx.beginPath(); ctx.moveTo(0,i*cell+0.5); ctx.lineTo(W*cell,i*cell+0.5); ctx.stroke();
        }
        for (let j=0;j<=W;j++){
          ctx.beginPath(); ctx.moveTo(j*cell+0.5,0); ctx.lineTo(j*cell+0.5,H*cell); ctx.stroke();
        }
      }

      // --- Fallback flattening (avoid "unsupported shape") ---
      // Flatten any nested array to [H, W] by keeping first dim as H and flattening the rest into W.
      function flattenFrameTo2D(frame) {
        // frame can be scalar, 1D, 2D, or higher-rank nested arrays
        if (!Array.isArray(frame)) {
          return { H: 1, W: 1, get: (_i,_j)=>Number(frame) };
        }
        const H = frame.length;
        if (H === 0) return { H: 0, W: 0, get: ()=>0 };
        if (!Array.isArray(frame[0])) {
          // 1D -> treat as 1xN
          const W = frame.length;
          return { H: 1, W, get: (_i,j)=>Number(frame[j]) };
        }
        // 2D or higher: flatten each row deeply
        const rows = new Array(H);
        let Wmax = 0;
        for (let i=0;i<H;i++){
          const row = frame[i];
          const flat = [];
          const stack = [row];
          while (stack.length){
            const cur = stack.pop();
            if (Array.isArray(cur)){
              for (let k=cur.length-1;k>=0;k--) stack.push(cur[k]);
            } else {
              flat.push(Number(cur));
            }
          }
          rows[i] = flat;
          if (flat.length > Wmax) Wmax = flat.length;
        }
        return {
          H, W: Wmax,
          get: (i,j) => (j < rows[i].length ? rows[i][j] : 0)
        };
      }

      function attachHover(canvas, getter, name) {
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const info = getter();
          if (!info){ setHoverText(""); return; }
          if (info.type==='vector'){
            const j = Math.floor(x / info.cell);
            if (j < 0 || j >= info.N){ setHoverText(""); return; }
            setHoverText(`${name} • ${info.which} • vector: t=${info.t}, j=${j}, value=${String(info.get(j))}`);
          } else {
            const i = Math.floor(y / info.cell);
            const j = Math.floor(x / info.cell);
            if (i<0||j<0||i>=info.H||j>=info.W){ setHoverText(""); return; }
            setHoverText(`${name} • ${info.which} • matrix: t=${info.t}, i=${i}, j=${j}, value=${String(info.get(i,j))}`);
          }
        });
        canvas.addEventListener('mouseleave', () => { setHoverText(""); });
      }

      function buildProbeList(probesMap){
        const names = Object.keys(probesMap);
        for (const n of names){
          if (!selectedState.has(n)) selectedState.set(n, true);
        }

        elProbeList.innerHTML = '';
        for (const name of names){
          const p = probesMap[name];
          const row = document.createElement('div');
          row.className = 'probeRow';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = !!selectedState.get(name);
          cb.addEventListener('change', () => {
            selectedState.set(name, cb.checked);
            detectAndRender();
          });

          const span = document.createElement('span');
          span.textContent = name;

          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = p?.type ? p.type : 'probe';

          row.appendChild(cb);
          row.appendChild(span);
          row.appendChild(badge);

          row.addEventListener('click', (e) => {
            if (e.target === cb) return;
            cb.checked = !cb.checked;
            selectedState.set(name, cb.checked);
            detectAndRender();
          });

          elProbeList.appendChild(row);
        }
      }

      function setAllProbes(checked){
        const probesMap = algo?.probes || {};
        for (const name of Object.keys(probesMap)){
          selectedState.set(name, checked);
        }
        detectAndRender();
      }

      function buildCard(name, probeInfo, isVector){
        const card = document.createElement('div');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'cardHeader';

        const title = document.createElement('div');
        title.className = 'title';
        title.textContent = name;

        const sub = document.createElement('div');
        sub.className = 'subtitle';
        sub.textContent = probeInfo?.type ? probeInfo.type : '';

        header.appendChild(title);
        header.appendChild(sub);

        const body = document.createElement('div');
        body.className = isVector ? 'vectorStack' : 'matrixRow';

        function mkBlock(which){
          const block = document.createElement('div');
          block.className = 'block';

          const bt = document.createElement('div');
          bt.className = 'blockTitle mono';
          const left = document.createElement('span'); left.textContent = which;
          const right = document.createElement('span'); right.className = 'shapeNote mono';
          bt.appendChild(left); bt.appendChild(right);

          const wrap = document.createElement('div');
          wrap.className = 'canvasWrap';

          const c = document.createElement('canvas');

          wrap.appendChild(c);
          block.appendChild(bt);
          block.appendChild(wrap);

          c._hoverGetter = null;
          attachHover(c, ()=>c._hoverGetter && c._hoverGetter(), name);

          return {block, canvas:c, shapeEl:right};
        }

        const bTrue = mkBlock('true');
        const bPred = mkBlock('pred');
        const bErr  = mkBlock('err');

        body.appendChild(bTrue.block);
        body.appendChild(bPred.block);
        body.appendChild(bErr.block);

        card.appendChild(header);
        card.appendChild(body);

        card._cTrue = bTrue.canvas; card._cPred = bPred.canvas; card._cErr = bErr.canvas;
        card._sTrue = bTrue.shapeEl; card._sPred = bPred.shapeEl; card._sErr = bErr.shapeEl;

        return card;
      }

      function computeGlobalMaxHW(){
        const probesMap = algo?.probes || {};
        const globalLengths = Array.isArray(algo?.lengths) ? algo.lengths : null;
        let maxH = 0, maxW = 0;
        for (const name of Object.keys(probesMap)){
          const p = probesMap[name];
          if (!p || p.error) continue;
          const lengths = Array.isArray(p.lengths) ? p.lengths : globalLengths;
          try {
            const mT = makeTimeMatrixViewWithLengths(p.true, lengths);
            if (mT.H > maxH) maxH = mT.H;
            if (mT.W > maxW) maxW = mT.W;
          } catch(_) {}
          try {
            const mP = makeTimeMatrixViewWithLengths(p.pred, lengths);
            if (mP.H > maxH) maxH = mP.H;
            if (mP.W > maxW) maxW = mP.W;
          } catch(_) {}
        }
        return {maxH, maxW};
      }

      function detectAndRender(){
        if (!algo) return;

        const probesMap = algo.probes || {};
        const globalLengths = Array.isArray(algo.lengths) ? algo.lengths : null;

        const algoName = algo.algorithm ? String(algo.algorithm) : 'algorithm';
        elAlgoName.textContent = `Loaded: ${algoName} • probes=${Object.keys(probesMap).length}`;
        elTopMeta.textContent = algoName;

        const vcell = Math.max(1, Math.min(120, Number(elVCell.value) || 13));
        const mcell = Math.max(1, Math.min(80, Number(elMCell.value) || 4));
        const contrast = Number(elContrast.value) || 1;
        elContrastLabel.textContent = `contrast=${contrast.toFixed(1)}`;

        // Compute global maximum 2D shape across all matrix-like probes
        const {maxH, maxW} = computeGlobalMaxHW();
        // Set defaults for submatrix end indices if unset (0)
        if (maxH > 0) {
          elR0.max = String(maxH);
          elR1.max = String(maxH);
          const curR1 = Number(elR1.value) || 0;
          if (curR1 === 0) elR1.value = String(maxH);
        }
        if (maxW > 0) {
          elC0.max = String(maxW);
          elC1.max = String(maxW);
          const curC1 = Number(elC1.value) || 0;
          if (curC1 === 0) elC1.value = String(maxW);
        }

        buildProbeList(probesMap);

        const selectedNames = Object.keys(probesMap).filter(n => !!selectedState.get(n));

        const vectorNames = [];
        const matrixNames = [];
        let effT = Infinity;
        let anyBatch=false; let allB1=true;

        const bIdx = Math.max(0, Number(elBidx.value) || 0);
        const tCapFromIsLast = validTFromIsLast(bIdx);
        const tCapFromLengths = validTFromLengths(bIdx, selectedNames);
        if (tCapFromIsLast != null) effT = Math.min(effT, tCapFromIsLast);
        else if (tCapFromLengths != null) effT = Math.min(effT, tCapFromLengths);

        // categorize
        for (const name of selectedNames){
          const p = probesMap[name];
          if (!p || p.error) continue;
          const lengths = Array.isArray(p.lengths) ? p.lengths : globalLengths;

          let T=null, B=null;
          const dimsTrue = getDims(p.true);
          const typeStr = String(p.type || '').toUpperCase();
          const locStr = String(p.location || '').toUpperCase();
          const axes = Array.isArray(p.axes) ? p.axes : Array.isArray(p.true?.axes) ? p.true.axes : null;

          // Helper: decide vector vs matrix based on metadata when available
          function preferVectorByMetadata(){
            // If location=NODE and not EDGE, prefer vector (per-node quantities)
            if (locStr === 'NODE') return true;
            // If axes has exactly one 'N' after B,T → vector; two 'N' → matrix
            if (Array.isArray(axes)){
              const nCount = axes.reduce((a,x)=>a + (String(x).toUpperCase()==='N'), 0);
              if (nCount === 1) return true;
            }
            // MASK_ONE typically denotes a one-hot over nodes; treat as vector unless explicitly EDGE
            if (typeStr === 'MASK_ONE' && locStr !== 'EDGE') return true;
            return false;
          }

          // categorical vector: [B,T,N,K]
          if (isCategoricalType(p.type) && dimsTrue.length === 4 && dimsTrue[3] <= 64) {
            vectorNames.push(name);
            try {
              const cv = makeTimeCategoricalVectorView(p.true, lengths);
              T = cv.T; B = cv.B;
            } catch(_) {}
          } else {
            const forceVector = preferVectorByMetadata();
            if (forceVector) {
              try {
                const v = makeTimeVectorViewWithLengths(p.true, lengths);
                vectorNames.push(name);
                T=v.T; B=v.B;
              } catch(_) {
                // If vector view fails, fall back to matrix
                try {
                  const m = makeTimeMatrixViewWithLengths(p.true, lengths);
                  matrixNames.push(name);
                  T=m.T; B=m.B;
                } catch(_) {}
              }
            } else {
              // default: try vector first, else matrix (existing heuristic)
              try {
                const v = makeTimeVectorViewWithLengths(p.true, lengths);
                vectorNames.push(name);
                T=v.T; B=v.B;
              } catch(_) {
                matrixNames.push(name);
                try {
                  const m = makeTimeMatrixViewWithLengths(p.true, lengths);
                  T=m.T; B=m.B;
                } catch(_) {}
              }
            }
          }

          if (T != null) effT = Math.min(effT, T);
          anyBatch = anyBatch || (B != null);
          if (B != null && B > 1) allB1 = false;
        }

        if (effT === Infinity) effT = 1;

        const prevT = Number(elT.value)||0;
        elT.max = Math.max(0, effT>0 ? effT-1 : 0);
        const tIdx = Math.min(prevT, Number(elT.max));
        elT.value = String(tIdx);
        elTLabel.textContent = `t=${elT.value} / ${elT.max}`;

        elBidx.parentElement.style.visibility = (!anyBatch || allB1) ? 'hidden' : 'visible';

        elCardsContainer.innerHTML = '';

        function getScaleFor(name, probe, lengths){
          if (!elLockScale.checked) return null;
          if (!scaleCache.has(name)) scaleCache.set(name, computeProbeScale(probe, lengths));
          return scaleCache.get(name);
        }
        function getErrScaleFor(name, probe, lengths){
          if (!elLockScale.checked) return null;
          const key = name + '|err';
          if (!scaleCache.has(key)) scaleCache.set(key, computeProbeErrScale(probe, lengths));
          return scaleCache.get(key);
        }

        // vectors first
        for (const name of vectorNames){
          const probe = probesMap[name];
          const lengths = Array.isArray(probe.lengths) ? probe.lengths : globalLengths;

          const card = buildCard(name, probe, true);
          elCardsContainer.appendChild(card);

          card._sTrue.textContent = `shape=${JSON.stringify(getDims(probe.true))}`;
          card._sPred.textContent = `shape=${JSON.stringify(getDims(probe.pred))}`;
          card._sErr.textContent  = `|pred-true|`;

          if (probe.error){
            const ctx = card._cTrue.getContext('2d');
            card._cTrue.width=520; card._cTrue.height=40;
            ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
            ctx.fillStyle='#333';
            ctx.fillText(`Error: ${probe.error}`, 6, 24);
            card._cPred.width=1; card._cPred.height=1;
            card._cErr.width=1; card._cErr.height=1;
            continue;
          }

          const dimsTrue = getDims(probe.true);
          const isCatVec = isCategoricalType(probe.type) && dimsTrue.length === 4 && dimsTrue[3] <= 64;

          if (isCatVec){
            // categorical vector [B,T,N,K]
            let vt=null, vp=null;
            try { vt = makeTimeCategoricalVectorView(probe.true, lengths); } catch(_) {}
            try { vp = makeTimeCategoricalVectorView(probe.pred, lengths); } catch(_) {}

            if (!(vt && vp)){
              // fallback flatten
              const frameT = probe.true?.[0]?.[tIdx] ?? probe.true;
              const frameP = probe.pred?.[0]?.[tIdx] ?? probe.pred;
              const fT = flattenFrameTo2D(frameT);
              const fP = flattenFrameTo2D(frameP);
              const scale = {bothIn01:true,min:0,max:1};
              drawMatrixTo(card._cTrue.getContext('2d'), card._cTrue, fT.H, fT.W, (i,j)=>fT.get(i,j), scale, mcell, contrast);
              drawMatrixTo(card._cPred.getContext('2d'), card._cPred, fP.H, fP.W, (i,j)=>fP.get(i,j), scale, mcell, contrast);
              drawMatrixTo(card._cErr.getContext('2d'),  card._cErr,  fT.H, fT.W, (i,j)=>Math.abs(fP.get(i,j)-fT.get(i,j)), {bothIn01:true,min:0,max:1}, mcell, contrast);
              continue;
            }

            const N = Math.min(vt.N, vp.N);
            const K = Math.min(vt.K, vp.K);

            const labelsTrue = new Array(N);
            const labelsPred = new Array(N);
            const mismatch = new Array(N);

            for (let j=0;j<N;j++){
              const vecT = new Array(K);
              const vecP = new Array(K);
              for (let k=0;k<K;k++){
                vecT[k] = Number(vt.get(tIdx,j,k));
                vecP[k] = Number(vp.get(tIdx,j,k));
              }
              const lt = argmax1D(vecT);
              const lp = argmax1D(vecP);
              labelsTrue[j] = lt;
              labelsPred[j] = lp;
              mismatch[j] = (lt === lp) ? 0 : 1;
            }

            drawCategoricalVector(card._cTrue.getContext('2d'), card._cTrue, labelsTrue, vcell);
            drawCategoricalVector(card._cPred.getContext('2d'), card._cPred, labelsPred, vcell);
            drawVectorTo(card._cErr.getContext('2d'), card._cErr, mismatch, {bothIn01:true,min:0,max:1}, vcell, contrast);

            card._cTrue._hoverGetter = ()=>({type:'vector',which:'true',t:tIdx,N,cell:vcell,get:(j)=>labelsTrue[j]});
            card._cPred._hoverGetter = ()=>({type:'vector',which:'pred',t:tIdx,N,cell:vcell,get:(j)=>labelsPred[j]});
            card._cErr._hoverGetter  = ()=>({type:'vector',which:'err', t:tIdx,N,cell:vcell,get:(j)=>mismatch[j]});
            continue;
          }

          // numeric vector
          let vTrue=null,vPred=null;
          try { vTrue = makeTimeVectorViewWithLengths(probe.true, lengths); } catch(_) {}
          try { vPred = makeTimeVectorViewWithLengths(probe.pred, lengths); } catch(_) {}

          if (!(vTrue && vPred)){
            // fallback flatten
            const frameT = probe.true?.[0]?.[tIdx] ?? probe.true;
            const frameP = probe.pred?.[0]?.[tIdx] ?? probe.pred;
            const fT = flattenFrameTo2D(frameT);
            const fP = flattenFrameTo2D(frameP);
            const scale = {bothIn01:true,min:0,max:1};
            drawMatrixTo(card._cTrue.getContext('2d'), card._cTrue, fT.H, fT.W, (i,j)=>fT.get(i,j), scale, mcell, contrast);
            drawMatrixTo(card._cPred.getContext('2d'), card._cPred, fP.H, fP.W, (i,j)=>fP.get(i,j), scale, mcell, contrast);
            drawMatrixTo(card._cErr.getContext('2d'),  card._cErr,  fT.H, fT.W, (i,j)=>Math.abs(fP.get(i,j)-fT.get(i,j)), {bothIn01:true,min:0,max:1}, mcell, contrast);
            continue;
          }

          const N = Math.min(vTrue.N, vPred.N);
          const rawTrue = new Array(N);
          const rawPred = new Array(N);
          for (let j=0;j<N;j++){
            rawTrue[j] = Number(vTrue.get(tIdx, j));
            rawPred[j] = Number(vPred.get(tIdx, j));
          }

          const locked = getScaleFor(name, probe, lengths);
          let scale = {bothIn01:true,min:0,max:1};
          if (locked) scale = locked;
          else {
            const tmin = Math.min(...rawTrue), tmax = Math.max(...rawTrue);
            const pmin = Math.min(...rawPred), pmax = Math.max(...rawPred);
            const bothIn01 = (tmin>=0 && tmax<=1 && pmin>=0 && pmax<=1);
            scale = bothIn01 ? {bothIn01:true,min:0,max:1} : {bothIn01:false,min:Math.min(tmin,pmin),max:Math.max(tmax,pmax)};
          }

          drawVectorTo(card._cTrue.getContext('2d'), card._cTrue, rawTrue, scale, vcell, contrast);
          drawVectorTo(card._cPred.getContext('2d'), card._cPred, rawPred, scale, vcell, contrast);

          const errLocked = getErrScaleFor(name, probe, lengths);
          const rawErr = rawPred.map((v,idx)=>Math.abs(v - rawTrue[idx]));
          let errScale = {bothIn01:true,min:0,max:1};
          if (errLocked) errScale = errLocked;
          else {
            const emax = Math.max(...rawErr, 0);
            errScale = (emax <= 1) ? {bothIn01:true,min:0,max:1} : {bothIn01:false,min:0,max:Math.max(emax,1e-6)};
          }
          drawVectorTo(card._cErr.getContext('2d'), card._cErr, rawErr, errScale, vcell, contrast);

          card._cTrue._hoverGetter = ()=>({type:'vector',which:'true',t:tIdx,N,cell:vcell,get:(j)=>rawTrue[j]});
          card._cPred._hoverGetter = ()=>({type:'vector',which:'pred',t:tIdx,N,cell:vcell,get:(j)=>rawPred[j]});
          card._cErr._hoverGetter  = ()=>({type:'vector',which:'err', t:tIdx,N,cell:vcell,get:(j)=>rawErr[j]});
        }

        // matrices second
        for (const name of matrixNames){
          const probe = probesMap[name];
          const lengths = Array.isArray(probe.lengths) ? probe.lengths : globalLengths;

          const card = buildCard(name, probe, false);
          elCardsContainer.appendChild(card);

          card._sTrue.textContent = `shape=${JSON.stringify(getDims(probe.true))}`;
          card._sPred.textContent = `shape=${JSON.stringify(getDims(probe.pred))}`;
          card._sErr.textContent  = `|pred-true|`;

          if (probe.error){
            const ctx = card._cTrue.getContext('2d');
            card._cTrue.width=520; card._cTrue.height=40;
            ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
            ctx.fillStyle='#333';
            ctx.fillText(`Error: ${probe.error}`, 6, 24);
            card._cPred.width=1; card._cPred.height=1;
            card._cErr.width=1; card._cErr.height=1;
            continue;
          }

          // Determine global submatrix selection
          let r0 = Math.max(0, parseInt(elR0.value||'0',10));
          let r1 = Math.max(0, parseInt(elR1.value||'0',10));
          let c0 = Math.max(0, parseInt(elC0.value||'0',10));
          let c1 = Math.max(0, parseInt(elC1.value||'0',10));

          const dimsTrue = getDims(probe.true);
          const isCatMat = isCategoricalType(probe.type) && dimsTrue.length === 5 && dimsTrue[4] <= 64;

          const t0 = tIdx;

          if (isCatMat){
            // categorical matrix [B,T,H,W,K]
            let mt=null, mp=null;
            try { mt = makeTimeCategoricalMatrixView(probe.true, lengths); } catch(_) {}
            try { mp = makeTimeCategoricalMatrixView(probe.pred, lengths); } catch(_) {}

            if (!(mt && mp)){
              // fallback flatten
              const frameT = probe.true?.[0]?.[t0] ?? probe.true;
              const frameP = probe.pred?.[0]?.[t0] ?? probe.pred;
              const fT = flattenFrameTo2D(frameT);
              const fP = flattenFrameTo2D(frameP);
              const scale = {bothIn01:true,min:0,max:1};
              drawMatrixTo(card._cTrue.getContext('2d'), card._cTrue, fT.H, fT.W, (i,j)=>fT.get(i,j), scale, mcell, contrast);
              drawMatrixTo(card._cPred.getContext('2d'), card._cPred, fP.H, fP.W, (i,j)=>fP.get(i,j), scale, mcell, contrast);
              drawMatrixTo(card._cErr.getContext('2d'),  card._cErr,  fT.H, fT.W, (i,j)=>Math.abs(fP.get(i,j)-fT.get(i,j)), {bothIn01:true,min:0,max:1}, mcell, contrast);
              continue;
            }

            const H = Math.min(mt.H, mp.H);
            const W = Math.min(mt.W, mp.W);
            const K = Math.min(mt.K, mp.K);

            if (!Number.isFinite(r0)) r0 = 0; if (!Number.isFinite(c0)) c0 = 0;
            if (!Number.isFinite(r1) || r1===0) r1 = H; if (!Number.isFinite(c1) || c1===0) c1 = W;
            r0 = Math.min(r0, H); r1 = Math.min(Math.max(r1, r0), H);
            c0 = Math.min(c0, W); c1 = Math.min(Math.max(c1, c0), W);
            const HH = Math.max(0, r1 - r0);
            const WW = Math.max(0, c1 - c0);

            // compute labels + mismatch
            const labelsTrue = new Array(HH);
            const labelsPred = new Array(HH);
            const mismatch = new Array(HH);
            for (let i=0;i<HH;i++){
              labelsTrue[i] = new Array(WW);
              labelsPred[i] = new Array(WW);
              mismatch[i] = new Array(WW);
              for (let j=0;j<WW;j++){
                // gather K
                let bestT=0, bestTv=Number(mt.get(t0,r0+i,c0+j,0));
                let bestP=0, bestPv=Number(mp.get(t0,r0+i,c0+j,0));
                for (let k=1;k<K;k++){
                  const tv = Number(mt.get(t0,r0+i,c0+j,k));
                  if (tv > bestTv) { bestTv = tv; bestT = k; }
                  const pv = Number(mp.get(t0,r0+i,c0+j,k));
                  if (pv > bestPv) { bestPv = pv; bestP = k; }
                }
                labelsTrue[i][j] = bestT;
                labelsPred[i][j] = bestP;
                mismatch[i][j] = (bestT === bestP) ? 0 : 1;
              }
            }

            drawCategoricalMatrix(card._cTrue.getContext('2d'), card._cTrue, HH, WW, (i,j)=>labelsTrue[i][j], mcell);
            drawCategoricalMatrix(card._cPred.getContext('2d'), card._cPred, HH, WW, (i,j)=>labelsPred[i][j], mcell);
            // mismatch as grayscale
            drawMatrixTo(card._cErr.getContext('2d'), card._cErr, HH, WW, (i,j)=>mismatch[i][j], {bothIn01:true,min:0,max:1}, mcell, contrast);

            card._cTrue._hoverGetter = ()=>({type:'matrix',which:'true',t:t0,H:HH,W:WW,cell:mcell,get:(i,j)=>labelsTrue[i][j]});
            card._cPred._hoverGetter = ()=>({type:'matrix',which:'pred',t:t0,H:HH,W:WW,cell:mcell,get:(i,j)=>labelsPred[i][j]});
            card._cErr._hoverGetter  = ()=>({type:'matrix',which:'err', t:t0,H:HH,W:WW,cell:mcell,get:(i,j)=>mismatch[i][j]});
            continue;
          }

          // numeric matrix
          let mTrue=null,mPred=null;
          try { mTrue = makeTimeMatrixViewWithLengths(probe.true, lengths); } catch(_) {}
          try { mPred = makeTimeMatrixViewWithLengths(probe.pred, lengths); } catch(_) {}

          if (!(mTrue && mPred)){
            // fallback flatten
            const frameT = probe.true?.[0]?.[t0] ?? probe.true;
            const frameP = probe.pred?.[0]?.[t0] ?? probe.pred;
            const fT = flattenFrameTo2D(frameT);
            const fP = flattenFrameTo2D(frameP);
            const scale = {bothIn01:true,min:0,max:1};
            drawMatrixTo(card._cTrue.getContext('2d'), card._cTrue, fT.H, fT.W, (i,j)=>fT.get(i,j), scale, mcell, contrast);
            drawMatrixTo(card._cPred.getContext('2d'), card._cPred, fP.H, fP.W, (i,j)=>fP.get(i,j), scale, mcell, contrast);
            drawMatrixTo(card._cErr.getContext('2d'),  card._cErr,  fT.H, fT.W, (i,j)=>Math.abs(fP.get(i,j)-fT.get(i,j)), {bothIn01:true,min:0,max:1}, mcell, contrast);
            continue;
          }

          const H = Math.min(mTrue.H, mPred.H);
          const W = Math.min(mTrue.W, mPred.W);

          if (!Number.isFinite(r0)) r0 = 0; if (!Number.isFinite(c0)) c0 = 0;
          if (!Number.isFinite(r1) || r1===0) r1 = H; if (!Number.isFinite(c1) || c1===0) c1 = W;
          r0 = Math.min(r0, H); r1 = Math.min(Math.max(r1, r0), H);
          c0 = Math.min(c0, W); c1 = Math.min(Math.max(c1, c0), W);
          const HH = Math.max(0, r1 - r0);
          const WW = Math.max(0, c1 - c0);

          const locked = getScaleFor(name, probe, lengths);
          let scale = {bothIn01:true,min:0,max:1};
          if (locked) scale = locked;
          else {
            const valsTrue = [];
            const valsPred = [];
            for (let i=r0;i<r1;i++){
              for (let j=c0;j<c1;j++){
                valsTrue.push(Number(mTrue.get(t0,i,j)));
                valsPred.push(Number(mPred.get(t0,i,j)));
              }
            }
            const tmin = Math.min(...valsTrue), tmax = Math.max(...valsTrue);
            const pmin = Math.min(...valsPred), pmax = Math.max(...valsPred);
            const bothIn01 = (tmin>=0 && tmax<=1 && pmin>=0 && pmax<=1);
            scale = bothIn01 ? {bothIn01:true,min:0,max:1} : {bothIn01:false,min:Math.min(tmin,pmin),max:Math.max(tmax,pmax)};
          }

          drawMatrixTo(card._cTrue.getContext('2d'), card._cTrue, HH, WW, (i,j)=>mTrue.get(t0,r0+i,c0+j), scale, mcell, contrast);
          drawMatrixTo(card._cPred.getContext('2d'), card._cPred, HH, WW, (i,j)=>mPred.get(t0,r0+i,c0+j), scale, mcell, contrast);

          const errLocked = getErrScaleFor(name, probe, lengths);
          let errScale = {bothIn01:true,min:0,max:1};
          if (errLocked) errScale = errLocked;
          else {
            let emax = 0;
            for (let i=0;i<HH;i++){
              for (let j=0;j<WW;j++){
                const e = Math.abs(Number(mPred.get(t0,r0+i,c0+j)) - Number(mTrue.get(t0,r0+i,c0+j)));
                if (Number.isFinite(e) && e > emax) emax = e;
              }
            }
            errScale = (emax <= 1) ? {bothIn01:true,min:0,max:1} : {bothIn01:false,min:0,max:Math.max(emax,1e-6)};
          }
          drawMatrixTo(card._cErr.getContext('2d'),  card._cErr,  HH, WW, (i,j)=>Math.abs(Number(mPred.get(t0,r0+i,c0+j)) - Number(mTrue.get(t0,r0+i,c0+j))), errScale, mcell, contrast);

          card._cTrue._hoverGetter = ()=>({type:'matrix',which:'true',t:t0,H:HH,W:WW,cell:mcell,get:(i,j)=>Number(mTrue.get(t0,r0+i,c0+j))});
          card._cPred._hoverGetter = ()=>({type:'matrix',which:'pred',t:t0,H:HH,W:WW,cell:mcell,get:(i,j)=>Number(mPred.get(t0,r0+i,c0+j))});
          card._cErr._hoverGetter  = ()=>({type:'matrix',which:'err', t:t0,H:HH,W:WW,cell:mcell,get:(i,j)=>Math.abs(Number(mPred.get(t0,r0+i,c0+j)) - Number(mTrue.get(t0,r0+i,c0+j)))});
        }

        elSummary.textContent = `selected=${selectedNames.length} • vectors=${vectorNames.length} • matrices=${matrixNames.length}`;

        // Update PCA rendering after probes render and UI updates
        renderPCA();
        renderPCANodes();
        if (tCapFromIsLast != null) {
          elMeta.textContent = `Using per-batch time from is_last: T_valid=${tCapFromIsLast} (batch ${bIdx}).`;
        } else if (tCapFromLengths != null) {
          elMeta.textContent = `Using per-batch time from lengths: T_valid=${tCapFromLengths} (batch ${bIdx}).`;
        } else {
          elMeta.textContent = `Tip: export algo.is_last to avoid viewing padded timesteps.`;
        }
      }

      // PCA rendering
      function renderPCA(){
        try {
          const hs = algo && algo.gnn_hidden_states && algo.gnn_hidden_states.data;
          const hasHS = Array.isArray(hs);
          elShowPca.disabled = !hasHS;
          if (!elShowPca.checked || !hasHS){
            elPcaContainer.style.display = 'none';
            elPcaInfo.textContent = hasHS ? 'PCA is available. Enable the checkbox to view.' : 'Hidden states not found in JSON.';
            return;
          }

          const bIdx = Math.max(0, Number(elBidx.value) || 0);
          // Determine valid T for this batch using is_last or lengths
          let Tvalid = validTFromIsLast(bIdx);
          if (Tvalid == null) {
            const Ls = Array.isArray(algo?.lengths) ? algo.lengths : null;
            if (Ls && Ls.length > bIdx) {
              const L = Number(Ls[bIdx]);
              if (Number.isFinite(L) && L > 0) Tvalid = L;
            }
          }
          // Fallback to full T
          if (Tvalid == null) {
            try { Tvalid = hs[Math.min(bIdx, hs.length-1)].length; } catch(_) { Tvalid = 1; }
          }

          const tVectors = PCA.flattenBTNDToTimeVectors(hs, bIdx, Tvalid);
          const T = tVectors.length;
          if (T === 0){
            elPcaContainer.style.display = 'none';
            elPcaInfo.textContent = 'No timesteps to show.';
            return;
          }

          const K = Math.min(10, T);
          const pca = PCA.fit(tVectors, K);

          const pcx = Math.max(1, Number(elPcx.value) || 1);
          const pcy = Math.max(1, Number(elPcy.value) || 2);
          const coords = PCA.projectXY(pca, pcx, pcy);

          // Canvas setup
          const dpr = window.devicePixelRatio || 1;
          const cssW = elPcaCanvas.clientWidth || 600;
          const cssH = elPcaCanvas.clientHeight || 320;
          elPcaCanvas.width = Math.max(1, Math.floor(cssW * dpr));
          elPcaCanvas.height = Math.max(1, Math.floor(cssH * dpr));
          const ctx = elPcaCanvas.getContext('2d');
          ctx.setTransform(dpr,0,0,dpr,0,0);
          ctx.clearRect(0,0,cssW,cssH);

          // Compute bounds with padding
          let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
          for (const p of coords){
            if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
            if (p.x < xmin) xmin = p.x; if (p.x > xmax) xmax = p.x;
            if (p.y < ymin) ymin = p.y; if (p.y > ymax) ymax = p.y;
          }
          if (!Number.isFinite(xmin) || !Number.isFinite(ymin)){
            elPcaContainer.style.display = 'none';
            elPcaInfo.textContent = 'PCA produced invalid coordinates.';
            return;
          }
          if (xmax === xmin) { xmax = xmin + 1e-6; }
          if (ymax === ymin) { ymax = ymin + 1e-6; }
          const padX = 0.08 * (xmax - xmin);
          const padY = 0.12 * (ymax - ymin);
          xmin -= padX; xmax += padX; ymin -= padY; ymax += padY;

          function sx(x){ return (x - xmin) / (xmax - xmin) * (cssW - 24) + 12; }
          function sy(y){ return (1 - (y - ymin) / (ymax - ymin)) * (cssH - 24) + 12; }

          // Axes
          ctx.strokeStyle = '#ddd';
          ctx.lineWidth = 1;
          ctx.strokeRect(10.5, 10.5, cssW-21, cssH-21);

          // Trajectory lines
          ctx.strokeStyle = '#4E79A7';
          ctx.lineWidth = 2;
          ctx.beginPath();
          let started=false;
          for (let i=0;i<coords.length;i++){
            const p = coords[i];
            const X = sx(p.x), Y = sy(p.y);
            if (!started){ ctx.moveTo(X,Y); started=true; }
            else ctx.lineTo(X,Y);
          }
          ctx.stroke();

          // Points
          const curT = Math.max(0, Math.min(T-1, Number(elT.value) || 0));
          for (let i=0;i<coords.length;i++){
            const p = coords[i];
            const X = sx(p.x), Y = sy(p.y);
            ctx.beginPath();
            ctx.arc(X, Y, (i===0 || i===T-1) ? 4 : 3, 0, Math.PI*2);
            if (i === curT) {
              ctx.fillStyle = '#E15759';
              ctx.fill();
            } else {
              ctx.fillStyle = (i===0) ? '#59A14F' : (i===T-1 ? '#B07AA1' : '#4E79A7');
              ctx.fill();
            }
          }

          elPcaContainer.style.display = '';
          const evx = pca.explained[Math.max(0, Math.min(pca.explained.length-1, pcx-1))] || 0;
          const evy = pca.explained[Math.max(0, Math.min(pca.explained.length-1, pcy-1))] || 0;
          elPcaInfo.textContent = `T=${T}, PCs available=${pca.K}. Var[X]=${(evx*100).toFixed(1)}%, Var[Y]=${(evy*100).toFixed(1)}%`;
          elPcaTitle.textContent = `PCA trajectory • PC${pcx} vs PC${pcy}`;
        } catch (e){
          elPcaContainer.style.display = 'none';
          elPcaInfo.textContent = `PCA error: ${e?.message || e}`;
        }
      }

      // events
      btnPlay.addEventListener('click', play);
      btnPause.addEventListener('click', stop);
      btnAll.addEventListener('click', ()=>setAllProbes(true));
      btnNone.addEventListener('click', ()=>setAllProbes(false));

      elT.addEventListener('input', () => { detectAndRender(); });
      elBidx.addEventListener('change', () => { stop(); scaleCache.clear(); detectAndRender(); });
      // PCA controls events
      elShowPca.addEventListener('change', renderPCA);
      elPcx.addEventListener('input', renderPCA);
      elPcy.addEventListener('input', renderPCA);

      elVCell.addEventListener('change', detectAndRender);
      elMCell.addEventListener('change', detectAndRender);
      elR0.addEventListener('input', detectAndRender);
      elR1.addEventListener('input', detectAndRender);
      elC0.addEventListener('input', detectAndRender);
      elC1.addEventListener('input', detectAndRender);

      elContrast.addEventListener('input', detectAndRender);
      elFps.addEventListener('change', () => { if (timer) play(); });

      elLockScale.addEventListener('change', () => { scaleCache.clear(); detectAndRender(); });

      window.addEventListener('resize', () => { detectAndRender(); });

      elFile.addEventListener('change', async () => {
        stop();
        const f = elFile.files?.[0];
        if (!f) return;
        const text = await f.text();
        let parsed = null;
        try { parsed = JSON.parse(text); } catch (e) { alert('Invalid JSON'); return; }

        if (!(parsed && parsed.probes && typeof parsed.probes === 'object')) {
          alert('Expected multi-probe JSON: { "algorithm": "...", "probes": { ... }, "is_last": [[...]] }');
          return;
        }

        algo = parsed;

        selectedState.clear();
        scaleCache.clear();

        elT.value = "0";
        elBidx.value = "0";
        setHoverText("Hover any cell to see its value here.");

        detectAndRender();
      });


      // Node-wise PCA rendering (unconnected set of N node points at current time)
      function renderPCANodes(){
        try {
          const hs = algo && algo.gnn_hidden_states && algo.gnn_hidden_states.data;
          const hasHS = Array.isArray(hs);
          // Enable/disable UI
          if (!hasHS){
            elShowPcaNodes.disabled = true;
            elPcaNodesContainer.style.display = 'none';
            elPcaNodesInfo.textContent = 'Hidden states not found in JSON.';
            return;
          } else {
            elShowPcaNodes.disabled = false;
          }
          if (!elShowPcaNodes.checked){
            elPcaNodesContainer.style.display = 'none';
            return;
          }

          const bIdx = Math.max(0, Number(elBidx.value) || 0);
          // Determine valid T for this batch using is_last or lengths
          let Tvalid = validTFromIsLast(bIdx);
          if (Tvalid == null) {
            const Ls = Array.isArray(algo?.lengths) ? algo.lengths : null;
            if (Ls && Ls.length > bIdx) {
              const L = Number(Ls[bIdx]);
              if (Number.isFinite(L) && L > 0) Tvalid = L;
            }
          }
          // Fallback to full T
          if (Tvalid == null) {
            try { Tvalid = hs[Math.min(bIdx, hs.length-1)].length; } catch(_) { Tvalid = 1; }
          }

          // Infer N and D
          const bt = hs[Math.min(bIdx, hs.length-1)] || [];
          const first = bt[0] || [];
          const N = Array.isArray(first) ? first.length : 0;
          const firstND = (N>0) ? first[0] : [];
          const D = Array.isArray(firstND) ? firstND.length : 1;

          // Build cache key and (re)fit PCA basis if needed — basis over ALL nodes across ALL valid timesteps
          const algoName = algo && algo.algorithm ? String(algo.algorithm) : 'algo';
          const cacheKey = `${algoName}|b=${bIdx}|T=${Tvalid}|N=${N}|D=${D}`;
          if (nodePcaCache.key !== cacheKey){
            let samples;
            try {
              samples = PCA.flattenBTNDToNodeSamples(hs, bIdx, Tvalid);
            } catch(e){
              elPcaNodesContainer.style.display = 'none';
              elPcaNodesInfo.textContent = 'Failed to build node samples for PCA.';
              return;
            }
            const K = Math.min(10, Math.min(D, samples.length));
            try {
              nodePcaCache.pca = PCA.fit(samples, K);
              nodePcaCache.key = cacheKey;
            } catch(e){
              elPcaNodesContainer.style.display = 'none';
              elPcaNodesInfo.textContent = 'PCA fitting failed.';
              return;
            }
          }

          const pca = nodePcaCache.pca;
          if (!pca){
            elPcaNodesContainer.style.display = 'none';
            elPcaNodesInfo.textContent = 'PCA basis not available.';
            return;
          }

          // Collect vectors for the CURRENT time (N x D)
          const curT = Math.max(0, Math.min((Tvalid||1)-1, Number(elT.value) || 0));
          const nodes = (bt && bt[curT]) ? bt[curT] : [];
          const vectors = new Array(N);
          for (let n=0;n<N;n++){
            const h = nodes[n] || [];
            const row = new Float64Array(D);
            if (Array.isArray(h)){
              for (let d=0; d<D; d++) row[d] = Number(h[d]) || 0;
            } else {
              row[0] = Number(h) || 0;
            }
            vectors[n] = row;
          }

          const pcx = Math.max(1, Number(elPcxNodes.value) || 1);
          const pcy = Math.max(1, Number(elPcyNodes.value) || 2);
          const pts = PCA.projectPointsXY(pca, vectors, pcx, pcy);

          // Canvas setup
          const dpr = window.devicePixelRatio || 1;
          const cssW = elPcaNodesCanvas.clientWidth || 600;
          const cssH = elPcaNodesCanvas.clientHeight || 320;
          elPcaNodesCanvas.width = Math.max(1, Math.floor(cssW * dpr));
          elPcaNodesCanvas.height = Math.max(1, Math.floor(cssH * dpr));
          const ctx = elPcaNodesCanvas.getContext('2d');
          ctx.setTransform(dpr,0,0,dpr,0,0);
          ctx.clearRect(0,0,cssW,cssH);

          // Bounds
          let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
          for (const p of pts){
            if (!p) continue;
            if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
            if (p.x < xmin) xmin = p.x; if (p.x > xmax) xmax = p.x;
            if (p.y < ymin) ymin = p.y; if (p.y > ymax) ymax = p.y;
          }
          if (!Number.isFinite(xmin) || !Number.isFinite(ymin)){
            elPcaNodesContainer.style.display = 'none';
            elPcaNodesInfo.textContent = 'PCA produced invalid coordinates for nodes.';
            return;
          }
          if (xmax === xmin) { xmax = xmin + 1e-6; }
          if (ymax === ymin) { ymax = ymin + 1e-6; }
          const padX = 0.08 * (xmax - xmin);
          const padY = 0.12 * (ymax - ymin);
          xmin -= padX; xmax += padX; ymin -= padY; ymax += padY;
          function sx(x){ return (x - xmin) / (xmax - xmin) * (cssW - 24) + 12; }
          function sy(y){ return (1 - (y - ymin) / (ymax - ymin)) * (cssH - 24) + 12; }

          // Axes box
          ctx.strokeStyle = '#ddd';
          ctx.lineWidth = 1;
          ctx.strokeRect(10.5, 10.5, cssW-21, cssH-21);

          // Points (unconnected)
          ctx.fillStyle = '#4E79A7';
          for (let i=0;i<pts.length;i++){
            const p = pts[i];
            const X = sx(p.x), Y = sy(p.y);
            ctx.beginPath();
            ctx.arc(X, Y, 3, 0, Math.PI*2);
            ctx.fill();
          }

          elPcaNodesContainer.style.display = '';
          const evx = pca.explained[Math.max(0, Math.min(pca.explained.length-1, pcx-1))] || 0;
          const evy = pca.explained[Math.max(0, Math.min(pca.explained.length-1, pcy-1))] || 0;
          elPcaNodesInfo.textContent = `N=${N}, T_basis=${Tvalid}, PCs available=${pca.K}. Var[X]=${(evx*100).toFixed(1)}%, Var[Y]=${(evy*100).toFixed(1)}%`;
        } catch (e){
          elPcaNodesContainer.style.display = 'none';
          elPcaNodesInfo.textContent = 'Error rendering node-wise PCA.';
        }
      }

      // Event listeners for node-wise PCA controls
      if (typeof elShowPcaNodes !== 'undefined'){
        elShowPcaNodes.addEventListener('change', ()=>{ renderPCANodes(); });
      }
      if (typeof elPcxNodes !== 'undefined'){
        elPcxNodes.addEventListener('input', ()=>{ renderPCANodes(); });
      }
      if (typeof elPcyNodes !== 'undefined'){
        elPcyNodes.addEventListener('input', ()=>{ renderPCANodes(); });
      }

    })();

      // Node-wise PCA rendering (unconnected set of N node points at current time)
      function renderPCANodes(){
        try {
          const hs = algo && algo.gnn_hidden_states && algo.gnn_hidden_states.data;
          const hasHS = Array.isArray(hs);
          // Enable/disable UI
          if (!hasHS){
            elShowPcaNodes.disabled = true;
            elPcaNodesContainer.style.display = 'none';
            elPcaNodesInfo.textContent = 'Hidden states not found in JSON.';
            return;
          } else {
            elShowPcaNodes.disabled = false;
          }
          if (!elShowPcaNodes.checked){
            elPcaNodesContainer.style.display = 'none';
            return;
          }

          const bIdx = Math.max(0, Number(elBidx.value) || 0);
          // Determine valid T for this batch using is_last or lengths
          let Tvalid = validTFromIsLast(bIdx);
          if (Tvalid == null) {
            const Ls = Array.isArray(algo?.lengths) ? algo.lengths : null;
            if (Ls && Ls.length > bIdx) {
              const L = Number(Ls[bIdx]);
              if (Number.isFinite(L) && L > 0) Tvalid = L;
            }
          }
          // Fallback to full T
          if (Tvalid == null) {
            try { Tvalid = hs[Math.min(bIdx, hs.length-1)].length; } catch(_) { Tvalid = 1; }
          }

          // Infer N and D
          const bt = hs[Math.min(bIdx, hs.length-1)] || [];
          const first = bt[0] || [];
          const N = Array.isArray(first) ? first.length : 0;
          const firstND = (N>0) ? first[0] : [];
          const D = Array.isArray(firstND) ? firstND.length : 1;

          // Build cache key and (re)fit PCA basis if needed — basis over ALL nodes across ALL valid timesteps
          const algoName = algo && algo.algorithm ? String(algo.algorithm) : 'algo';
          const cacheKey = `${algoName}|b=${bIdx}|T=${Tvalid}|N=${N}|D=${D}`;
          if (nodePcaCache.key !== cacheKey){
            let samples;
            try {
              samples = PCA.flattenBTNDToNodeSamples(hs, bIdx, Tvalid);
            } catch(e){
              elPcaNodesContainer.style.display = 'none';
              elPcaNodesInfo.textContent = 'Failed to build node samples for PCA.';
              return;
            }
            const K = Math.min(10, Math.min(D, samples.length));
            try {
              nodePcaCache.pca = PCA.fit(samples, K);
              nodePcaCache.key = cacheKey;
            } catch(e){
              elPcaNodesContainer.style.display = 'none';
              elPcaNodesInfo.textContent = 'PCA fitting failed.';
              return;
            }
          }

          const pca = nodePcaCache.pca;
          if (!pca){
            elPcaNodesContainer.style.display = 'none';
            elPcaNodesInfo.textContent = 'PCA basis not available.';
            return;
          }

          // Collect vectors for the CURRENT time (N x D)
          const curT = Math.max(0, Math.min((Tvalid||1)-1, Number(elT.value) || 0));
          const nodes = (bt && bt[curT]) ? bt[curT] : [];
          const vectors = new Array(N);
          for (let n=0;n<N;n++){
            const h = nodes[n] || [];
            const row = new Float64Array(D);
            if (Array.isArray(h)){
              for (let d=0; d<D; d++) row[d] = Number(h[d]) || 0;
            } else {
              row[0] = Number(h) || 0;
            }
            vectors[n] = row;
          }

          const pcx = Math.max(1, Number(elPcxNodes.value) || 1);
          const pcy = Math.max(1, Number(elPcyNodes.value) || 2);
          const pts = PCA.projectPointsXY(pca, vectors, pcx, pcy);

          // Canvas setup
          const dpr = window.devicePixelRatio || 1;
          const cssW = elPcaNodesCanvas.clientWidth || 600;
          const cssH = elPcaNodesCanvas.clientHeight || 320;
          elPcaNodesCanvas.width = Math.max(1, Math.floor(cssW * dpr));
          elPcaNodesCanvas.height = Math.max(1, Math.floor(cssH * dpr));
          const ctx = elPcaNodesCanvas.getContext('2d');
          ctx.setTransform(dpr,0,0,dpr,0,0);
          ctx.clearRect(0,0,cssW,cssH);

          // Bounds
          let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
          for (const p of pts){
            if (!p) continue;
            if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
            if (p.x < xmin) xmin = p.x; if (p.x > xmax) xmax = p.x;
            if (p.y < ymin) ymin = p.y; if (p.y > ymax) ymax = p.y;
          }
          if (!Number.isFinite(xmin) || !Number.isFinite(ymin)){
            elPcaNodesContainer.style.display = 'none';
            elPcaNodesInfo.textContent = 'PCA produced invalid coordinates for nodes.';
            return;
          }
          if (xmax === xmin) { xmax = xmin + 1e-6; }
          if (ymax === ymin) { ymax = ymin + 1e-6; }
          const padX = 0.08 * (xmax - xmin);
          const padY = 0.12 * (ymax - ymin);
          xmin -= padX; xmax += padX; ymin -= padY; ymax += padY;
          function sx(x){ return (x - xmin) / (xmax - xmin) * (cssW - 24) + 12; }
          function sy(y){ return (1 - (y - ymin) / (ymax - ymin)) * (cssH - 24) + 12; }

          // Axes box
          ctx.strokeStyle = '#ddd';
          ctx.lineWidth = 1;
          ctx.strokeRect(10.5, 10.5, cssW-21, cssH-21);

          // Points (unconnected)
          ctx.fillStyle = '#4E79A7';
          for (let i=0;i<pts.length;i++){
            const p = pts[i];
            const X = sx(p.x), Y = sy(p.y);
            ctx.beginPath();
            ctx.arc(X, Y, 3, 0, Math.PI*2);
            ctx.fill();
          }

          elPcaNodesContainer.style.display = '';
          const evx = pca.explained[Math.max(0, Math.min(pca.explained.length-1, pcx-1))] || 0;
          const evy = pca.explained[Math.max(0, Math.min(pca.explained.length-1, pcy-1))] || 0;
          elPcaNodesInfo.textContent = `N=${N}, T_basis=${Tvalid}, PCs available=${pca.K}. Var[X]=${(evx*100).toFixed(1)}%, Var[Y]=${(evy*100).toFixed(1)}%`;
        } catch (e){
          elPcaNodesContainer.style.display = 'none';
          elPcaNodesInfo.textContent = 'Error rendering node-wise PCA.';
        }
      }

      // Event listeners for node-wise PCA controls
      if (typeof elShowPcaNodes !== 'undefined'){
        elShowPcaNodes.addEventListener('change', ()=>{ renderPCANodes(); });
      }
      if (typeof elPcxNodes !== 'undefined'){
        elPcxNodes.addEventListener('input', ()=>{ renderPCANodes(); });
      }
      if (typeof elPcyNodes !== 'undefined'){
        elPcyNodes.addEventListener('input', ()=>{ renderPCANodes(); });
      }
</script>
</body>
</html>

